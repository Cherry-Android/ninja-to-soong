// Copyright 2024 ninja-to-soong authors
// SPDX-License-Identifier: Apache-2.0

use std::collections::HashMap;
use std::collections::HashSet;

use crate::ninja_target::*;
use crate::project::Project;
use crate::soong_module::SoongModule;
use crate::utils::*;

#[derive(Debug)]
pub struct SoongPackage<'a> {
    package: String,
    generated_deps: HashSet<String>,
    include_directories: HashSet<String>,
    generated_libraries: HashSet<String>,
    src_root: &'a str,
    ndk_root: &'a str,
    build_root: &'a str,
    target_prefix: &'a str,
}

impl<'a> SoongPackage<'a> {
    pub fn new(
        src_root: &'a str,
        ndk_root: &'a str,
        build_root: &'a str,
        target_prefix: &'a str,
        default_visibility: &str,
        license_kinds: &str,
        license_text: &str,
    ) -> Self {
        let mut package = SoongPackage {
            package: String::new(),
            generated_deps: HashSet::new(),
            include_directories: HashSet::new(),
            generated_libraries: HashSet::new(),
            src_root,
            ndk_root,
            build_root,
            target_prefix,
        };
        package.package += "//
// This file has been auto-generated by ninja-to-soong
//
// ******************************
// *** DO NOT MODIFY MANUALLY ***
// ******************************
//
// https://github.com/rjodinchr/ninja-to-soong
//

";
        let license_name =
            target_prefix.to_string() + "_" + &license_text.replace(".", "_").to_lowercase();

        let mut package_module = SoongModule::new("package");
        package_module.add_set("default_applicable_licenses", [license_name.clone()].into());
        package_module.add_set(
            "default_visibility",
            [default_visibility.to_string()].into(),
        );
        package.add_module(package_module);

        let mut license_module = SoongModule::new("license");
        license_module.add_str("name", license_name.clone());
        license_module.add_set("visibility", [":__subpackages__".to_string()].into());
        license_module.add_set("license_kinds", [license_kinds.to_string()].into());
        license_module.add_set("license_text", [license_text.to_string()].into());
        package.add_module(license_module);

        package
    }

    pub fn add_module(&mut self, module: SoongModule) {
        self.package += &module.print();
    }

    pub fn write(self, project_repo_name: &str) -> Result<(), String> {
        const ANDROID_BP: &str = "/Android.bp";
        write_file(&(self.src_root.to_string() + ANDROID_BP), &self.package)?;
        let tests_path = get_tests_folder()?;
        copy_file(
            &(self.src_root.to_string() + ANDROID_BP),
            &(add_slash_suffix(&tests_path) + project_repo_name + ANDROID_BP),
            true,
        )?;
        Ok(())
    }

    pub fn get_generated_deps(&self) -> HashSet<String> {
        self.generated_deps.to_owned()
    }

    pub fn get_include_directories(&self) -> HashSet<String> {
        self.include_directories.to_owned()
    }

    pub fn get_generated_libraries(&self) -> HashSet<String> {
        self.generated_libraries.to_owned()
    }

    fn generate_library(
        &mut self,
        name: &str,
        target: &NinjaTarget,
        target_map: &NinjaTargetMap,
        project: &dyn Project,
    ) -> Result<String, String> {
        let mut cflags = project.get_default_cflags();
        let mut includes: HashSet<String> = HashSet::new();
        let mut srcs: HashSet<String> = HashSet::new();
        for input in target.get_inputs() {
            let Some(target) = target_map.get(input) else {
                return error!(format!("unsupported input for library: {input}"));
            };

            let target_srcs = target.get_inputs();
            if target_srcs.len() != 1 {
                return error!(format!("Too many inputs in target: {self:#?}"));
            }
            srcs.insert(target_srcs[0].replace(&add_slash_suffix(self.src_root), ""));

            for inc in target.get_includes(self.src_root, project) {
                includes.insert(inc.clone());
                self.include_directories.insert(inc);
            }

            for define in target.get_defines(project) {
                cflags.insert(String::from("-D") + &define);
            }
        }

        let (version_script, link_flags) = target.get_link_flags(self.src_root, project);
        let (static_libs, shared_libs, generated_libraries) =
            target.get_link_libraries(self.ndk_root, project)?;
        self.generated_libraries.extend(generated_libraries);
        let generated_headers = target.get_generated_headers(target_map)?;
        self.generated_deps
            .extend(project.get_headers_to_copy(&generated_headers));
        let generated_headers_filtered_raw = project.get_headers_to_generate(&generated_headers);
        let mut generated_headers_filtered = HashSet::new();
        for header in generated_headers_filtered_raw {
            generated_headers_filtered.insert(match target_map.get(&header) {
                Some(target_header) => target_header.get_name(self.target_prefix),
                None => return error!(format!("Could not find target for '{header}'")),
            });
        }
        let target_name = target.get_name(self.target_prefix);

        let mut module = crate::soong_module::SoongModule::new(name);
        if project.optimize_target_for_size(&target_name) {
            module.add_bool("optimize_for_size", true);
        }
        module.add_bool("use_clang_lld", true);
        module.add_set("srcs", srcs);
        module.add_set("local_include_dirs", includes);
        module.add_set("cflags", cflags);
        module.add_set("ldflags", link_flags);
        module.add_set("static_libs", static_libs);
        module.add_set("shared_libs", shared_libs);
        module.add_set("header_libs", project.get_target_header_libs(&target_name));
        module.add_set("generated_headers", generated_headers_filtered);
        module.add_str("version_script", version_script);
        module.add_str("stem", project.get_target_stem(&target_name));
        module.add_str("name", target_name);
        Ok(module.print())
    }

    fn replace_output_in_command(
        &self,
        command: String,
        output: &String,
        project: &dyn Project,
    ) -> String {
        let marker = "<output>";
        let space_and_marker = String::from(" ") + marker;
        let space_and_last_output = String::from(" ") + output.split("/").last().unwrap();
        let command = command.replace(output, marker);
        let command = command.replace(&space_and_last_output, &space_and_marker);
        let replace_output =
            String::from("$(location ") + &project.get_command_output(output) + ")";
        command.replace(marker, &replace_output)
    }

    fn replace_input_in_command(&self, command: String, input: String) -> String {
        let replace_input = String::from("$(location ")
            + &input.replace(&add_slash_suffix(self.src_root), "")
            + ")";
        command.replace(&input, &replace_input)
    }

    fn replace_dep_in_command(
        &self,
        command: String,
        dep: String,
        dep_target_name: String,
        prefix: &str,
    ) -> String {
        let replace_dep = "$(location ".to_string() + &dep_target_name + ")";
        let dep_with_prefix = String::from(prefix) + &dep;
        command
            .replace(&dep_with_prefix, &replace_dep)
            .replace(&dep, &replace_dep)
    }

    fn remove_python_in_command(command: String) -> String {
        let mut command = command;
        while let Some(index) = command.find("bin/python") {
            let begin = std::str::from_utf8(&command.as_bytes()[0..index])
                .unwrap()
                .rfind(" ")
                .unwrap_or_default();
            command = match std::str::from_utf8(&command.as_bytes()[index..])
                .unwrap()
                .find(" ")
            {
                Some(end) => command.replace(
                    std::str::from_utf8(&command.as_bytes()[begin..index + end + 1]).unwrap(),
                    "",
                ),
                None => command.replace(
                    std::str::from_utf8(&command.as_bytes()[begin..]).unwrap(),
                    "",
                ),
            };
        }
        command
    }

    fn rework_command(
        &self,
        command: String,
        inputs: HashSet<String>,
        outputs: &Vec<String>,
        deps: HashSet<(String, String)>,
        project: &dyn Project,
    ) -> String {
        let mut command = Self::remove_python_in_command(command);
        command = command.replace(&add_slash_suffix(self.build_root), "");
        for output in outputs {
            command = self.replace_output_in_command(command, output, project);
        }
        for input in inputs.clone() {
            command = self.replace_input_in_command(command, input);
        }
        for (dep, dep_target_name) in deps {
            command =
                self.replace_dep_in_command(command, dep, dep_target_name, self.target_prefix);
        }
        command
    }

    fn generate_custom_command(
        &mut self,
        target: &NinjaTarget,
        command: String,
        project: &dyn Project,
    ) -> Result<String, String> {
        let (inputs, deps) = project.get_command_inputs_and_deps(target.get_inputs())?;
        let mut srcs_set: HashSet<String> = HashSet::new();
        for input in &inputs {
            srcs_set.insert(input.replace(&add_slash_suffix(self.src_root), ""));
        }
        for (dep, dep_target_name) in &deps {
            srcs_set.insert(dep_target_name.clone());
            self.generated_deps.insert(dep.clone());
        }
        let target_outputs = target.get_outputs();
        let out_set = target_outputs
            .into_iter()
            .fold(HashSet::new(), |mut set, output| {
                set.insert(project.get_command_output(output));
                set
            });

        let command = self.rework_command(command, inputs, target_outputs, deps, project);

        let mut module = crate::soong_module::SoongModule::new("cc_genrule");
        module.add_str("name", target.get_name(self.target_prefix));
        module.add_set("srcs", srcs_set);
        module.add_set("out", out_set);
        module.add_str("cmd", command.to_string());
        Ok(module.print())
    }

    fn generate_module(
        &mut self,
        target: &NinjaTarget,
        target_map: &NinjaTargetMap,
        project: &dyn Project,
    ) -> Result<Option<String>, String> {
        let rule = target.get_rule();
        Ok(Some(if rule.starts_with("CXX_SHARED_LIBRARY") {
            self.generate_library("cc_library_shared", target, target_map, project)
        } else if rule.starts_with("CXX_STATIC_LIBRARY") {
            self.generate_library("cc_library_static", target, target_map, project)
        } else if rule.starts_with("CUSTOM_COMMAND") {
            let command = match target.get_command()? {
                Some(command) => command,
                None => return Ok(None),
            };
            self.generate_custom_command(target, command, project)
        } else if rule.starts_with("CXX_COMPILER")
            || rule.starts_with("C_COMPILER")
            || rule.starts_with("ASM_COMPILER")
            || rule == "phony"
        {
            return Ok(None);
        } else {
            error!(format!("unsupported rule ({rule}) for target: {target:#?}"))
        }?))
    }

    pub fn generate(
        &mut self,
        mut target_to_generate: Vec<String>,
        targets: Vec<NinjaTarget>,
        project: &dyn Project,
    ) -> Result<(), String> {
        let mut target_seen: HashSet<String> = HashSet::new();
        let mut target_map: NinjaTargetMap = HashMap::new();
        for target in &targets {
            for output in &target.get_all_outputs() {
                target_map.insert(output.clone(), target);
            }
        }

        while let Some(input) = target_to_generate.pop() {
            if target_seen.contains(&input) || project.ignore_target(&input) {
                continue;
            }
            let Some(target) = target_map.get(&input) else {
                continue;
            };

            target_to_generate.append(&mut target.get_all_inputs());
            for output in target.get_all_outputs() {
                target_seen.insert(output);
            }

            if let Some(module) = self.generate_module(target, &target_map, project)? {
                self.package += &module;
            }
        }
        Ok(())
    }
}
